import java.awt.geom.Rectangle2D;
import java.awt.geom.Rectangle2D.Double;
import java.awt.geom.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Vector;

import org.json.*;
import java.net.*;

/**
 * NOT IN USE. For setting up problem. Generate optimum locations for a cell tower to be located at based on inputed cell phone data and cell tower data
 * Commented out everything that required the elevation data because of the time constraints it put on generating the problem for a large scale
 * uncomment to use that feature again, I switched to a different optimum location function to speed up scaling of problem,
 * @required Location.java CellPhone.java Point.java Peak.java* 
 * *unfortunately.. can edit and change just not an issue so haven't gotten to it
 */
public class OptimumLocations {
	private final static String ElevationKey = "AIzaSyByUEe71wQ_jl6uvkKyW5yMdQlurD7HYpY";
	private final String USER_AGENT = "Mozilla/5.0";
	private CellPhone[] cellPhones;
	private double towerPower;
	private Set<Location> locations;
	
	//getters and setters
	public CellPhone[] getCellPhones() {
		return cellPhones;
	}
	public void setCellPhones(CellPhone[] cellPhones) {
		this.cellPhones = cellPhones;
	}
	public double getTowerPower() {
		return towerPower;
	}
	public void setTowerPower(double towerPower) {
		this.towerPower = towerPower;
	}
	public Set<Location> getLocations() {
		return locations;
	}
	public void setLocations(Set<Location> locations) {
		this.locations = locations;
	}

	/**
	 * constructor
	 * @param cellPhones - set of all cell phones to take in to consideration
	 * @param power - power of cell tower
	 */
	public OptimumLocations(Set<CellPhone> cellPhones, double power){
		this.cellPhones = cellPhones.toArray(new CellPhone[cellPhones.size()]);
		this.towerPower = power;
		this.locations = new HashSet<Location>();
	}
	
	/**
	 * determine possible domain based on cell phones and test with elevation api if optimum locations exist
	 * obtain domain of all possible cell phone set combinations
	 * test largest sets first and if successful eliminates need for smaller sets
	 * commented out elevation api aspect because it took too long to generate setup so cell tower locations based on perfect circles
	 * @throws Exception - Elevation API doesn't work
	 */
	public void optimizeLocation() throws Exception{
		//obtain optimum areas for each set of cellPhones
		Vector<LocationSet> domain = new Vector<LocationSet>();
		domain = findLocations();
		//order set largest -> smallest
		Object[] orderedDomain = domain.toArray();
		orderedDomain = bubbleSort(orderedDomain);
		//run elevation API in order
		int num = 0;
		for(Object locationSet : orderedDomain){
			//check if flagged for already being done
			if(((LocationSet) locationSet).isFlagged()){
				continue;
			}
			Vector<Point> testPoints = ((LocationSet) locationSet).getBoundary();
			//test top 10 peaks chosen from a few location paths
			Peak[] peaks = getMidPoints(testPoints);
			Vector<Peak> workingPeaks = new Vector<Peak>();
			//run elevation algorithm on top ten peak points to see if it reaches all locations
			for(int x = 0; x < peaks.length; x++){
				Area peakArea = generateCircle(peaks[x].getLat(), peaks[x].getLng(), this.towerPower);
				boolean overlapAll = true;
				for(CellPhone phone : ((LocationSet) locationSet).getCellPhoneSet()){
					if(!phone.isOverlapping(peakArea)){
						overlapAll = false;
						break;
					}
				}
				if(overlapAll){
					workingPeaks.addElement(peaks[x]);
					break; //for now until testing closest distance is done
				}
			}
			//if no working peaks then go to next subset
			if(workingPeaks.size() == 0){
				continue;
			}else{
				Set<CellPhone> cellSet = ((LocationSet) locationSet).getCellPhoneSet();
				//eliminate subsets from domain
				for(Object locSet : orderedDomain){
					if (((LocationSet) locSet).isContained(cellSet)){
						((LocationSet) locSet).setFlag(true);
					}
				}
				//TO DO::test lat,lng for one closest to other already chosen locations to minimize travel time
				this.locations.add(new Location(workingPeaks.get(0).getLat(),workingPeaks.get(0).getLng(),cellSet,num++));
			}
		}
	}
	/**
	 * obtain midpoints an area generated by points, most likely location of successful cell tower
	 * @param testPoints
	 * @return
	 */
	private Peak[] getMidPoints(Vector<Point> testPoints){
		Vector<Peak> peaks = new Vector<Peak>();
		for(Iterator<Point> it = testPoints.iterator(); it.hasNext();){
			Point point = it.next();
			Point midPoint = this.midPoint(testPoints.get(0).getLat(), testPoints.get(0).getLat(), point.getLat(), point.getLng());
			peaks.addElement(new Peak(midPoint.getLat(), midPoint.getLng(), 0));
		}
		return  peaks.toArray(new Peak[peaks.size()]);
	}
			
			
	/*private Area generateArea(Peak peak) throws Exception{
		double radians;
		Path2D.Double bounds = new Path2D.Double();
		for(radians = 0; radians <= 6.28; radians +=(2*Math.PI/40)){
			//find farthest point possible in direction of bearing
			Point farthestPoint = calculateNewPoint(this.towerPower,radians,peak.getLat(),peak.getLng());
			//make elevation path api call to google elevation api
			//returns 50 elevation data points in the path determined by power and bearing
			String responseString = elevationCall(peak.getLat(),peak.getLng(),farthestPoint.getLat(),farthestPoint.getLng(), false).toString();
			JSONObject response = new JSONObject(responseString);
			JSONArray results = response.getJSONArray("results");
			//declare elevation and step variables
			double cellTowerElevation = results.getJSONObject(0).getDouble("elevation");
			double previousElevation = cellTowerElevation;
			double distance = this.towerPower;
			int steps = 0;
			//iterate down path decreasing distance by 1/50th and decreasing distance if elevation increases
			while(distance > 0){
				steps++;
				
				if (steps > 49) { //maximum size reached so set lat, lng to max
					steps = 49;
					break;
				}
				//subtract step forward from distance
				distance -= this.towerPower/49;
				double currentElevation = results.getJSONObject(steps).getDouble("elevation");
				//if currentElevation is higher than cell phone elevation and the previous elevation 
				//then subtract change from the larger of cellPhone and previous
				if (currentElevation > cellTowerElevation){
					if (currentElevation > previousElevation){
						if(cellTowerElevation > previousElevation){
							distance -= 15*(currentElevation - cellTowerElevation);
						}else{
							distance -= 15*(currentElevation - previousElevation);
						}
					}
				}
				previousElevation = currentElevation;				
			}
			//save the last step and elevation of it to bounds path, convert meters overshot in to currect lat/lng
			//by using negative distance and bearing back to center point for equation
			double farthestLat = results.getJSONObject(steps).getJSONObject("location").getDouble("lat");
			double farthestLng = results.getJSONObject(steps).getJSONObject("location").getDouble("lng");
			Point finalPoint = calculateNewPoint(Math.abs(distance),radians+Math.PI,farthestLat,farthestLng);
			//if first time then place bound start there, after that make lines
			//coordinateString += "[" + finalPoint.getLng() +"," +finalPoint.getLat() + "], ";
			
			if (radians == 0){
				bounds.moveTo(finalPoint.getLat(),finalPoint.getLng());
			}else{
				bounds.lineTo(finalPoint.getLat(), finalPoint.getLng());
			}
			
		}
		//close off path and make class area equal to  it
		//writer.println(coordinateString);
		//writer.println("]");
		//writer.println("}");
		//writer.close();
		bounds.closePath();
		return new Area(bounds);
	}*/
		
	/*private Peak[] acquirePeaks(Vector<Point> testPoints) throws Exception{
		Peak[] peaks = new Peak[10]; 
		int increment = Math.floorDiv(testPoints.size(), 3);
		//if test size less 3 than just do increment of 1
		if(increment == 0){
			increment = 1;
		}
		for(int x = 0; x < testPoints.size(); x+=increment){
			for(Point point : testPoints){
				if(point == testPoints.elementAt(x)){
					continue;
				}else{
					Point midPoint = this.midPoint(testPoints.get(x).getLat(),testPoints.get(x).getLat(), point.getLat(), point.getLng());
					//hit elevation API with path
					String responseString = elevationCall(testPoints.elementAt(x).getLat(),testPoints.elementAt(x).getLng(),point.getLat(),point.getLng(), true).toString();
					JSONObject response = new JSONObject(responseString);
					JSONArray results = response.getJSONArray("results");
					//test results against array of top peaks
					for(int y = 0; y < 20; y++){
						//grab point and place in object
						double elevation = results.getJSONObject(y).getDouble("elevation");
						double lat = results.getJSONObject(y).getJSONObject("location").getDouble("lat");
						double lng = results.getJSONObject(y).getJSONObject("location").getDouble("lng");
						Peak peak = new Peak(lat,lng,elevation);
						Peak test = peak;
						for(int z = 0; z < peaks.length; z++){
							if(peaks[z] == null){
								//place then break to next point
								peaks[z] = test;
								break;
							}else{
								//bubble out
								if(peaks[z].getElevation() < test.getElevation()){
									Peak temp = peaks[z];
									peaks[z] = test;
									test = temp;
								}
							}
						}
					}
					
				}
			}
		}
		return peaks;
	}*/
	/*private StringBuffer elevationCall(double lat, double lng, double lat2, double lng2, boolean isPeakFinding) throws Exception{
		//make api call to google elevation api
		String ELEVATION_API_URL =  "https://maps.googleapis.com/maps/api/elevation/json?";
		String urlParameters;
		//decrease sample size for peak finding
		if(isPeakFinding){
			urlParameters = "path=" + lat + "," + lng +"%7C"+lat2+"," + lng2 + "&samples=20&key="+OptimumLocations.ElevationKey;
		}else{
			urlParameters = "path=" + lat + "," + lng +"%7C"+lat2+"," + lng2 + "&samples=50&key="+OptimumLocations.ElevationKey;	
		}
	    
	    URL obj = new URL(ELEVATION_API_URL + urlParameters);
	    HttpURLConnection con = (HttpURLConnection) obj.openConnection();

	    //add request header
	    con.setRequestMethod("POST");
	    con.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
	    con.setRequestProperty("Content-Language", "en-US");
	    
	    // optional default is GET
	 	con.setRequestMethod("GET");

	 	//add request header
	 	con.setRequestProperty("User-Agent", USER_AGENT);

	 	//int responseCode = con.getResponseCode();
	 	//System.out.println("\nSending 'GET' request to URL : " + ELEVATION_API_URL + urlParameters);
	 	//System.out.println("Response Code : " + responseCode);

	 	BufferedReader in = new BufferedReader(
	 		       new InputStreamReader(con.getInputStream()));
	 	String inputLine;
	 	StringBuffer response = new StringBuffer();

	 	while ((inputLine = in.readLine()) != null) {
	 		response.append(inputLine);
	 	}
	 	in.close();

	 	//print result
	 	//System.out.println(response.toString());
	 	return response;
	}*/
	/**
	 * sorts the list of cell phone sets largest to smallest to test more optimal spots firsts
	 * @param arr - set of cell phones in array to be ordered
	 * @return Object[] - ordered array
	 */
	private Object[] bubbleSort(Object[] arr){
		LocationSet temp = new LocationSet(null);
		for(int i=0; i < arr.length-1; i++){
			 
            for(int j=1; j < arr.length-i; j++){
                if(((LocationSet) arr[j-1]).getCellPhoneSet().size() < ((LocationSet) arr[j]).getCellPhoneSet().size()){
                    temp=(LocationSet) arr[j-1];
                    arr[j-1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
		return arr;
	}
	/**
	 * create circles on the boundary of every cell phone and see what overlaps to generate the space of possible domains. Since I switched to only doing
	 * circles the list of possible domains all work. Since this is true I switched over to OptimumLocations2.java and stopped using this class
	 * @return
	 */
	public Vector<LocationSet> findLocations(){
		//create circles around each area and test overlap
		//create set of points associated with each set
		Vector<LocationSet> domain = new Vector<LocationSet>();
		//Area boundingArea = boundingRectangle();
		for(CellPhone phone : this.cellPhones){
			//add singular domain location sets
			Set<CellPhone> newSet = new HashSet<CellPhone>();
			newSet.add(phone);
			LocationSet singularSet = new LocationSet(newSet);
			domain.add(singularSet);
			
			//create circles around outline of phone area test where it overlaps with other areas
			Vector<Point> phoneBoundary = phone.getPoints();
			double lat = phone.getLat();
			double lng = phone.getLng();
			for(Point point: phoneBoundary){
				//test if in bounded area
				/*if(!boundingArea.contains(phone.getLng(),phone.getLat())){
					continue;
				}*/
				//find center of circle being created
				double bearing = calculateBearing(lat,point.getLat(),lng,point.getLng());
				Point centerPoint = calculateNewPoint(this.towerPower, bearing, point.getLat(), point.getLng());
				//generate circle convert to java Area object
				Area circleArea = generateCircle(centerPoint.getLat(),centerPoint.getLng(),this.towerPower);
				Set<CellPhone> pointSet = new HashSet<CellPhone>();
				pointSet.add(phone);
				//test if circle area overlaps other cell phone areas
				for(CellPhone testPhone : this.cellPhones){
					if (testPhone == phone){
						continue;
					}else{
						if(testPhone.isOverlapping(circleArea)){
							pointSet.add(testPhone);
							//System.out.println(phone.getName() + " " + testPhone.getName());
						}
					}
					
				}
				
				//place point in proper set location
				boolean isEqual = false;
				for(LocationSet set : domain){
					if(set.isContained(pointSet)){
						set.addBoundaryPoint(centerPoint);
					}
					if(!isEqual){
						isEqual = set.isEqual(pointSet);
					}
				}
				//if never equal add to locationSet domain
				if(!isEqual){
					LocationSet set = new LocationSet(pointSet);
					set.addBoundaryPoint(centerPoint);
					domain.add(set);
				}
				
			}
		}
		return domain;
	}
	/*private Area boundingRectangle(){
		double smallestLat = cellPhones[0].getLat();
		double smallestLng = cellPhones[0].getLng();
		double largestLat = cellPhones[0].getLat();
		double largestLng = cellPhones[0].getLng();
		for(CellPhone phone: this.cellPhones){
			if(phone.getLat() < smallestLat){
				smallestLat = phone.getLat();
			}
			if(phone.getLat() > largestLat){
				largestLat = phone.getLat();
			}
			if(phone.getLng() < smallestLng){
				smallestLng = phone.getLng();
			}
			if(phone.getLng() > largestLng){
				largestLng = phone.getLng();
			}
		}
		double width = largestLng - smallestLng;
		double height = largestLat - smallestLat;
		Rectangle2D.Double rectangle = new Double(smallestLng,largestLat,width,height);
		return new Area(rectangle);
	}*/
	/**
	 * generates a circle given a center and radius
	 * @param lat - latitude of center
	 * @param lng - longitude of center
	 * @param power - power aka radius
	 * @return Area - java Area generated from bounding points in a path to make a circle* with resolution 40(arbitrarily picked 40 points to bound path)
	 */
	private Area generateCircle(double lat, double lng, double power){
		double radians;
		Path2D.Double bounds = new Path2D.Double();
		for(radians = 0; radians <= 6.28; radians +=(2*Math.PI/40)){
			//find farthest point possible in direction of bearing
			Point farthestPoint = calculateNewPoint(power,radians,lat,lng);
			if (radians == 0){
				bounds.moveTo(farthestPoint.getLat(),farthestPoint.getLng());
			}else{
				bounds.lineTo(farthestPoint.getLat(), farthestPoint.getLng());
			}
		}
		bounds.closePath();
		Area circle = new Area(bounds);
		return circle;
	}
	/**
	 * given one point calculate its bearing towards another point
	 * @param lat1
	 * @param lat2
	 * @param lng1
	 * @param lng2
	 * @return double - bearing in degrees from 0
	 */
	private double calculateBearing(double lat1, double lat2, double lng1, double lng2){
		lat1 = Math.toRadians(lat1);
		lat2 = Math.toRadians(lat2);
		lng1 = Math.toRadians(lng1);
		lng2 = Math.toRadians(lng2);
		
		double y = Math.sin(lng2-lng1) * Math.cos(lat2);
		double x = Math.cos(lat1)*Math.sin(lat2) -
		        Math.sin(lat1)*Math.cos(lat2)*Math.cos(lng2-lng1);
		double brng = Math.atan2(y, x);
		return brng;
	}
	/**
	 * calculates midpoint of two points
	 * @param lat1
	 * @param lon1
	 * @param lat2
	 * @param lon2
	 * @return Point - exactly in the middle of two points
	 */
	public Point midPoint(double lat1,double lon1,double lat2,double lon2){

	    double dLon = Math.toRadians(lon2 - lon1);

	    //convert to radians
	    lat1 = Math.toRadians(lat1);
	    lat2 = Math.toRadians(lat2);
	    lon1 = Math.toRadians(lon1);

	    double Bx = Math.cos(lat2) * Math.cos(dLon);
	    double By = Math.cos(lat2) * Math.sin(dLon);
	    double lat3 = Math.atan2(Math.sin(lat1) + Math.sin(lat2), Math.sqrt((Math.cos(lat1) + Bx) * (Math.cos(lat1) + Bx) + By * By));
	    double lon3 = lon1 + Math.atan2(By, Math.cos(lat1) + Bx);

	    //print out in degrees
	    //System.out.println(Math.toDegrees(lat3) + " " + Math.toDegrees(lon3));
	    return new Point(Math.toDegrees(lat3),Math.toDegrees(lon3));
	}
	/**
	 * based on distance, bearing and a point calculate where that new point is
	 * @param distance
	 * @param bearing
	 * @param lat
	 * @param lng
	 * @return Point at a distance and bearing from current point
	 */
	private Point calculateNewPoint(double distance, double bearing, double lat, double lng) {
		//convert lat/lng to radians and distance in relation to radius of earth
		//http://www.movable-type.co.uk/scripts/latlong.html
		double dist = distance/6371000.0;
		double brng = bearing;
		double lat1 = Math.toRadians(lat);
		double lon1 = Math.toRadians(lng);

		double lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) + Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );
		double a = Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1), Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));
		//System.out.println("a = " +  a);
		double lon2 = lon1 + a;

		lon2 = (lon2+ 3*Math.PI) % (2*Math.PI) - Math.PI;
		//convert from radians back to degrees
		lat2 = Math.toDegrees(lat2);
		lon2 = Math.toDegrees(lon2);
		Point newPoint = new Point(lat2,lon2);
		return newPoint;
	}
	
	public static void main(String[] args) throws Exception{
		
		//manually implement elevation until api calling works
		/*double[][] phone1Points = {{-106.364471,39.18721647242402},{-106.34507299081098,39.18695543667812},{-106.32829066121754,39.1783375932975},{-106.31016818596622,39.17463119821012},{-106.29692064881338,39.16409088820595},{-106.27801853933934,39.15902594578697},{-106.27850132546106,39.14043842626069},{-106.27387545828087,39.12779833752079},{-106.26857092356799,39.11616383246622},{-106.25753501914332,39.10512149438643},{-106.26868001567838,39.09198681808788},{-106.25641905936047,39.078686430354146},{-106.24223323838629,39.06112262347062},{-106.24340757721751,39.04405092575889},{-106.24878592757709,39.02667438256181},{-106.28222024099757,39.028104014390344},{-106.31241679618523,39.03636624967053},{-106.33537232669876,39.04767111425486},{-106.34596442179581,39.04779110510782},{-106.35786930561426,39.05965426787044},{-106.364471,39.060171377419934},{-106.3743174306068,39.043742385093154},{-106.38230847083564,39.04938806715249},{-106.38872231910402,39.05505296451079},{-106.40555035335933,39.0481105543418},{-106.40927882876002,39.057221814857584},{-106.42145091944558,39.059867263862245},{-106.43001421193206,39.066075824306246},{-106.40519193184235,39.08174846617384},{-106.39539544910754,39.088217414365594},{-106.38664504258188,39.09201747129287},{-106.388084227995,39.09492046812273},{-106.39615414278411,39.100008659130935},{-106.41129251762561,39.110530515823065},{-106.40226017942632,39.11332261352408},{-106.40155213954999,39.12078726291095},{-106.41278330195574,39.14358905684545},{-106.40330121036219,39.15111572047749},{-106.39100902450329,39.15535811105319},{-106.37927953721348,39.16451898714492},{-106.364471,39.18721647242402}};
		double[][] phone2Points = {{-106.585832,38.88728427482806},{-106.57128468874313,38.90685505325521},{-106.55466773617745,38.91001166063449},{-106.53957117752196,38.90602361591494},{-106.52879279854278,38.89646608365018},{-106.51710610424317,38.88885267060347},{-106.50608080301801,38.88045891794641},{-106.50113901367484,38.86894747883977},{-106.48665147356878,38.86043154792511},{-106.49428953144135,38.846636586384385},{-106.48991551087865,38.83534121595519},{-106.49483101110388,38.82411553116758},{-106.48806273452459,38.810586991152135},{-106.50822962592582,38.80454358246694},{-106.52741755267759,38.80229316263697},{-106.53714399163829,38.79742602855778},{-106.54873381216026,38.795577951382896},{-106.55042631071417,38.781204171148566},{-106.5599856260954,38.77336007156399},{-106.571845370764,38.76652495419867},{-106.585832,38.785539384423444},{-106.59309451911554,38.79964370760091},{-106.59843709955734,38.80514989498714},{-106.60519071113924,38.805772943643525},{-106.62356517566005,38.79489846701324},{-106.63005346060841,38.800898076779845},{-106.63497812135972,38.8075472678473},{-106.62585828950981,38.819486258982224},{-106.6128229683564,38.828542848719685},{-106.62320153525228,38.830765741285255},{-106.62004004512474,38.83537619767723},{-106.61312654603846,38.83874423502834},{-106.61945040497977,38.84388443454759},{-106.61556465339098,38.84717696247805},{-106.61999480641795,38.8547068347077},{-106.62262726387344,38.86402661190179},{-106.61925087483102,38.87118842543596},{-106.61127181725568,38.874250545068506},{-106.60540397652667,38.882268957543964},{-106.59643865029417,38.8875088295821},{-106.585832,38.88728427482806}};
		double[][] phone3Points = {{-106.096297,38.835741283669385},{-106.06387966633639,38.828257560344674},{-106.03263038147048,38.821478649211734},{-106.01097826816302,38.79928169013013},{-105.99407168607263,38.7784723968335},{-105.97465666914434,38.76361159324394},{-105.95520982679825,38.74868106362976},{-105.9646082627396,38.72108698511022},{-105.9584276993371,38.70370925061932},{-105.96282320171396,38.685259926111435},{-105.93621036050284,38.66870989589539},{-105.9332411856616,38.64854363570387},{-105.95443103056103,38.63271910382093},{-105.9343369362882,38.60422308504994},{-105.93983991509904,38.57986676278127},{-105.97447514517489,38.573523712032596},{-105.94239778582876,38.50295993522583},{-105.96929339065645,38.473617926053365},{-106.02224053569337,38.490386055617215},{-106.06051144946639,38.49197381415103},{-106.096297,38.502899623785204},{-106.1297100876689,38.50369524960588},{-106.15146792098741,38.53595479132009},{-106.17273268627386,38.55143841062876},{-106.19749941248071,38.559863232547485},{-106.19638921100024,38.59051534925827},{-106.20518126435653,38.6069636386518},{-106.18033500279338,38.6353329416355},{-106.19061221211948,38.64484967842361},{-106.17948343765362,38.65849000549686},{-106.20123605588215,38.668780731300544},{-106.20775301389388,38.68255661803917},{-106.1744852953626,38.68859454176095},{-106.21435296240838,38.71568265970235},{-106.16051980332277,38.705164767169336},{-106.1797560920442,38.73387966220886},{-106.21037619276952,38.79116252689457},{-106.20227281599713,38.83079366264019},{-106.17206414197629,38.85039535955093},{-106.13469990480384,38.8576214080994},{-106.09629700000002,38.835741283669385}};
		double[][] phone4Points = {{-106.12391700000002,39.46853408029594},{-106.11480504813538,39.46798011791068},{-106.1059178888765,39.46633189722835},{-106.09747473786162,39.46363007859345},{-106.08968379823659,39.459941307596004},{-106.0827371041269,39.45535656246508},{-106.07680577300779,39.4499888993141},{-106.07203578574808,39.44397065219216},{-106.06854439885409,39.43745015847125},{-106.06641727657073,39.43058809178255},{-106.06570641153827,39.42355349421774},{-106.06642888224408,39.41651960661576},{-106.06877728197473,39.40971252161739},{-106.075450921986,39.40447663345177},{-106.08112530431987,39.39953547321025},{-106.08567786657494,39.394010284217174},{-106.09088154902608,39.38842137818924},{-106.1024874719594,39.391062261618515},{-106.10593996420731,39.38080133241129},{-106.11481665382482,39.37915517212512},{-106.12391700000002,39.37860191970407},{-106.1325537988752,39.38141854507978},{-106.14189403579272,39.38080133241129},{-106.1503288780572,39.38349994190451},{-106.15811448314079,39.38718466914852},{-106.16505933909924,39.391764931745534},{-106.17099250838558,39.39712811236397},{-106.17576783019642,39.40314231573604},{-106.17926752584088,39.40965960031969},{-106.18140511775589,39.41651960661576},{-106.1821275884617,39.42355349421774},{-106.18141672342928,39.43058809178255},{-106.17928960114594,39.43745015847125},{-106.17579821425193,39.44397065219216},{-106.17102822699222,39.4499888993141},{-106.1650968958731,39.45535656246508},{-106.15815020176342,39.459941307596004},{-106.1503592621385,39.46363007859345},{-106.1419161111235,39.46633189722835},{-106.13302895186463,39.46798011791068},{-106.12391700000002,39.46853408029594}};
		CellPhone cellPhone1 = new CellPhone(39.092029, -106.364471,15000, phone1Points, "Cabin");
		CellPhone cellPhone2 = new CellPhone(38.835383, -106.585832,12000, phone2Points, "Lake");
		CellPhone cellPhone3 = new CellPhone(38.668834, -106.096297,25000, phone3Points, "CEO");
		CellPhone cellPhone4 = new CellPhone(39.423568, -106.123917,5000, phone4Points, "Intern");
		
		CellPhone[] cellPhones = {cellPhone1, cellPhone2, cellPhone3, cellPhone4};
		
		OptimumLocations locations = new OptimumLocations(cellPhones, 20000);
		locations.optimizeLocation();*/

	}


}
